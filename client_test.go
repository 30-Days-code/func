package faas_test

import (
	"fmt"
	"os"
	"path/filepath"
	"testing"

	"github.com/boson-project/faas"
	"github.com/boson-project/faas/mock"
)

// TestNew ensures that instantiation succeeds or fails as expected.
func TestNew(t *testing.T) {
	// New client with all defaults
	_, err := faas.New()
	if err != nil {
		t.Fatal(err)
	}

	// New client with optional verbosity enabled
	_, err = faas.New(faas.WithVerbose(true))
	if err != nil {
		t.Fatal(err)
	}
}

// TestNewWithInterferingFiles asserts that attempting to create a new client rooted
// to a directory with any visible files or any known contentious files (configs) fails.
func TestNewWithInterferingFiles(t *testing.T) {
	// TODO
}

// TestCreate ensures that creation of a supported language succeeds with all
// defaults (base case).
func TestCreate(t *testing.T) {
	// Client with all defaults other than an initializer that verifies the
	// specified language.
	client, err := faas.New(
		faas.WithInitializer(mock.NewInitializer()))
	if err != nil {
		t.Fatal(err)
	}

	// Create the test function root
	root := "testdata/example.com/admin"
	os.MkdirAll(root, 0700)
	defer os.RemoveAll(root)

	// A supported langauge should not error, even when both language and name are empty.
	if err := client.Create("go", "", root); err != nil {
		t.Fatal(err)
	}
}

// TestCreateUnderivableName ensures that attempting to create a new function
// when the name is underivable (and no explicit name is provided) generates
// an error.
func TestCreateUnderivableName(t *testing.T) {

	// Create the test function root
	root := "testdata/example.com/admin"
	os.MkdirAll(root, 0700)
	defer os.RemoveAll(root)

	// Instantiation without an explicit service name, but no derivable service
	// name (because of limiting path recursion) should fail.
	client, err := faas.New(
		faas.WithDomainSearchLimit(0)) // limit ability to derive from path.
	if err != nil {
		t.Fatal(err)
	}

	// create a Service Function with a missing name, but when the name is
	// underivable (in this case due to limited recursion, but would equally
	// apply if run from /tmp or similar)
	if err := client.Create("go", "", ""); err == nil {
		t.Fatal("did not receive expected error")
	}

}

// TestCreateMissingLanguage ensures that instantiation fails if the required
// language parameter is not passed to Create.
func TestCreateMissingLanguage(t *testing.T) {
	client, err := faas.New(
		faas.WithInitializer(mock.NewInitializer()))
	if err != nil {
		t.Fatal(err)
	}

	// create a Service Function call missing language should error
	if err := client.Create("", "", ""); err == nil {
		t.Fatal("missing language did not generate error")
	}
}

// TestCreateUnsupportedLanguage ensures that instantiation fails if the required
// language parameter is of an unsupported language.
func TestCreateUnsupportedLanguage(t *testing.T) {
	client, err := faas.New(
		faas.WithInitializer(mock.NewInitializer())) // validtes language passed
	if err != nil {
		t.Fatal(err)
	}

	// create a Service Function call witn an unsupported language should bubble
	// the error generated by the underlying initializer.
	if err := client.Create("cobol", "", ""); err == nil {
		t.Fatal("unsupported language did not generate error")
	}
}

// TestCreateDelegeates ensures that a call to Create invokes the Service Function
// Initializer, Builder, Pusher and Deployer with expected parameters.
func TestCreateDelegates(t *testing.T) {
	var (
		root        = "testdata/example.com/admin" // .. in which to initialize
		name        = "admin.example.com"          // expected to be derived
		image       = "my.hub/user/imagestamp"     // expected image
		route       = "https://admin.example.com/" // expected final route
		initializer = mock.NewInitializer()
		builder     = mock.NewBuilder()
		pusher      = mock.NewPusher()
		deployer    = mock.NewDeployer()
	)

	// Create the test function root
	os.MkdirAll(root, 0700)
	defer os.RemoveAll(root)

	client, err := faas.New(
		faas.WithInitializer(initializer), // will receive the final value
		faas.WithBuilder(builder),         // builds an image
		faas.WithPusher(pusher),           // pushes images to a registry
		faas.WithDeployer(deployer),       // deploys images as a running service
	)
	if err != nil {
		t.Fatal(err)
	}

	// Register function delegates on the mocks which validate assertions
	// -------------

	// The initializer should receive the name expected from the path,
	// the passed language, and an absolute path to the funciton soruce.
	initializer.InitializeFn = func(name, language, path string) error {
		if name != "admin.example.com" {
			t.Fatalf("initializer expected name 'admin.example.com', got '%v'", name)
		}
		if language != "go" {
			t.Fatalf("initializer expected language 'go', got '%v'", language)
		}
		expectedPath, err := filepath.Abs("./testdata/example.com/admin")
		if err != nil {
			t.Fatal(err)
		}
		if path != expectedPath {
			t.Fatalf("initializer expected path '%v', got '%v'", expectedPath, path)
		}
		return nil
	}

	// The builder should be invoked with a service name and path to its source
	// function code.  For this test, it is a name derived from the test path.
	// An example image name is returned.
	builder.BuildFn = func(name2, path2 string) (string, error) {
		if name != name {
			t.Fatalf("builder expected name %v, got '%v'", name, name2)
		}
		expectedPath, err := filepath.Abs(root)
		if err != nil {
			t.Fatal(err)
		}
		if path2 != expectedPath {
			t.Fatalf("builder expected path '%v', got '%v'", expectedPath, root)
		}
		// The final image name will be determined by the builder implementation,
		// but whatever it is (in this case fabricated); it should be returned
		// and later provided to the pusher.
		return image, nil
	}

	// The pusher should be invoked with the image to push.
	pusher.PushFn = func(image2 string) error {
		if image2 != image {
			t.Fatalf("pusher expected image '%v', got '%v'", image, image2)
		}
		// image of given name wouold be pushed to the configured registry.
		return nil
	}

	// The deployer should be invoked with the service name and image, and return
	// the final accessible address.
	deployer.DeployFn = func(name2, image2 string) (address string, err error) {
		if name2 != name {
			t.Fatalf("deployer expected name '%v', got '%v'", name, name2)
		}
		if image2 != image {
			t.Fatalf("deployer expected image '%v', got '%v'", image, image2)
		}
		// service of given name would be deployed using the given image and
		// allocated route returned.
		return route, nil
	}

	// Invocation
	// -------------

	// Invoke the creation, triggering the function delegates, and
	// perform follow-up assertions that the functions were indeed invoked.
	if err := client.Create("go", "", root); err != nil {
		t.Fatal(err)
	}

	// Confirm that each delegate was invoked.
	if !initializer.InitializeInvoked {
		t.Fatal("initializer was not invoked")
	}
	if !builder.BuildInvoked {
		t.Fatal("builder was not invoked")
	}
	if !pusher.PushInvoked {
		t.Fatal("pusher was not invoked")
	}
	if !deployer.DeployInvoked {
		t.Fatal("deployer was not invoked")
	}
}

// TestCreateLocal ensures that when set to local-only mode, Create only invokes
// the initializer and builder.
func TestCreateLocal(t *testing.T) {
	var (
		root        = "testdata/example.com/admin"
		initializer = mock.NewInitializer()
		builder     = mock.NewBuilder()
		pusher      = mock.NewPusher()
		deployer    = mock.NewDeployer()
		dnsProvider = mock.NewDNSProvider()
	)

	// Create the test function root
	os.MkdirAll(root, 0700)
	defer os.RemoveAll(root)

	// Create the test function root
	os.MkdirAll(root, 0700)
	defer os.RemoveAll(root)

	client, err := faas.New(
		faas.WithInitializer(initializer), // will receive the final value
		faas.WithBuilder(builder),         // builds an image
		faas.WithPusher(pusher),           // pushes images to a registry
		faas.WithDeployer(deployer),       // deploys images as a running service
		faas.WithDNSProvider(dnsProvider), // will receive the final value
		faas.WithLocal(true),              // set to local function mode.
	)
	if err != nil {
		t.Fatal(err)
	}

	// Create a new Service Function
	if err := client.Create("go", "", root); err != nil {
		t.Fatal(err)
	}
	// Ensure that none of the remote delegates were invoked
	if pusher.PushInvoked {
		t.Fatal("Push invoked in local mode.")
	}
	if deployer.DeployInvoked {
		t.Fatal("Deploy invoked in local mode.")
	}
	if dnsProvider.ProvideInvoked {
		t.Fatal("DNS provider invoked in local mode.")
	}

}

// TestCreateInternal ensures that when set to internal mode, Creation invokes the deployer with the "no public route" option and subsequent updates also are flagged to not create the route.
func TestCreateInternal(t *testing.T) {
	fmt.Printf("TODO: TestCreateInternal")
}

// TestCreateDomain ensures that the effective domain is dervied from
// directory structure.  See the unit tests for pathToDomain for details.
func TestCreateDomain(t *testing.T) {
	// Create the test function root
	root := "testdata/example.com/admin"
	os.MkdirAll(root, 0700)
	defer os.RemoveAll(root)

	// the mock dns provider does nothing but receive the caluclated
	// domain name via it's Provide(domain) method, which is the value
	// being tested here.
	dnsProvider := mock.NewDNSProvider()

	client, err := faas.New(
		faas.WithDomainSearchLimit(1),     // Limit recursion to one level
		faas.WithDNSProvider(dnsProvider), // will receive the final value
	)
	if err != nil {
		t.Fatal(err)
	}

	if err := client.Create("go", "", root); err != nil {
		t.Fatal(err)
	}
	if !dnsProvider.ProvideInvoked {
		t.Fatal("dns provider was not invoked")
	}
	if dnsProvider.NameRequested != "admin.example.com" {
		t.Fatalf("expected 'example.com', got '%v'", dnsProvider.NameRequested)
	}
}

// TestCreateSubdomain ensures that a subdirectory is interpreted as a subdomain
// when calculating final domain.  See the unit tests for pathToDomain for the
// details and edge cases of this caluclation.
func TestCreateSubdomain(t *testing.T) {
	// Create the test function root
	root := "testdata/example.com/admin"
	os.MkdirAll(root, 0700)
	defer os.RemoveAll(root)

	dnsProvider := mock.NewDNSProvider()
	client, err := faas.New(
		faas.WithDomainSearchLimit(2),
		faas.WithDNSProvider(dnsProvider),
	)
	if err != nil {
		t.Fatal(err)
	}
	if err := client.Create("go", "", root); err != nil {
		t.Fatal(err)
	}
	if !dnsProvider.ProvideInvoked {
		t.Fatal("dns provider was not invoked")
	}
	if dnsProvider.NameRequested != "admin.example.com" {
		t.Fatalf("expected 'admin.example.com', got '%v'", dnsProvider.NameRequested)
	}
}

// TestRun ensures that the runner is invoked with the absolute path requested.
func TestRun(t *testing.T) {
	// a previously-initilized function's root
	root := "testdata/example.com/www"

	runner := mock.NewRunner()
	client, err := faas.New(
		faas.WithRunner(runner))
	if err != nil {
		t.Fatal(err)
	}
	if err := client.Run(root); err != nil {
		t.Fatal(err)
	}
	if !runner.RunInvoked {
		t.Fatal("run did not invoke the runner")
	}
	absRoot, err := filepath.Abs(root)
	if err != nil {
		t.Fatal(err)
	}
	if runner.RootRequested != absRoot {
		t.Fatalf("expected path '%v', got '%v'", absRoot, runner.RootRequested)
	}
}

// TestUpdate ensures that the updater properly invokes the build/push/deploy
// process, erroring if run on a directory uncreated.
func TestUpdate(t *testing.T) {
	var (
		root    = "testdata/example.com/www"     // .. expected to be initialized
		name    = "www.example.com"              // expected to be derived
		image   = "my.hub/user/admin.exampe.com" // expected image
		builder = mock.NewBuilder()
		pusher  = mock.NewPusher()
		updater = mock.NewUpdater()
	)

	client, err := faas.New(
		faas.WithBuilder(builder), // builds an image
		faas.WithPusher(pusher),   // pushes images to a registry
		faas.WithUpdater(updater), // updates deployed image
	)
	if err != nil {
		t.Fatal(err)
	}

	// Register function delegates on the mocks which validate assertions
	// -------------

	// The builder should be invoked with a service name and path to its source
	// function code.  For this test, it is a name derived from the test path.
	// An example image name is returned.
	builder.BuildFn = func(name2, path2 string) (string, error) {
		if name != name {
			t.Fatalf("builder expected name %v, got '%v'", name, name2)
		}
		// The final image name will be determined by the builder implementation,
		// but whatever it is (in this case fabricated); it should be returned
		// and later provided to the pusher.
		return image, nil
	}

	// The pusher should be invoked with the image to push.
	pusher.PushFn = func(image2 string) error {
		if image2 != image {
			t.Fatalf("pusher expected image '%v', got '%v'", image, image2)
		}
		// image of given name wouold be pushed to the configured registry.
		return nil
	}

	// The updater should be invoked with the service name and image.
	// Actual logic of updating is an implementation detail.
	updater.UpdateFn = func(name2, image2 string) error {
		if name2 != name {
			t.Fatalf("updater expected name '%v', got '%v'", name, name2)
		}
		if image2 != image {
			t.Fatalf("updater expected image '%v', got '%v'", image, image2)
		}
		return nil
	}

	// Invocation
	// -------------

	// Invoke the creation, triggering the function delegates, and
	// perform follow-up assertions that the functions were indeed invoked.
	if err := client.Update(root); err != nil {
		t.Fatal(err)
	}

	if !builder.BuildInvoked {
		t.Fatal("builder was not invoked")
	}
	if !pusher.PushInvoked {
		t.Fatal("pusher was not invoked")
	}
	if !updater.UpdateInvoked {
		t.Fatal("updater was not invoked")
	}
}

// TestRemove ensures that the remover is invoked with the name of the
// client's associated service function.
func TestRemove(t *testing.T) {
	var (
		name    = "admin.example.com"
		remover = mock.NewRemover()
	)

	client, err := faas.New(
		faas.WithRemover(remover))
	if err != nil {
		t.Fatal(err)
	}
	remover.RemoveFn = func(name2 string) error {
		if name2 != name {
			t.Fatalf("remover expected name '%v' got '%v'", name, name2)
		}
		return nil
	}
	// Call remove with no explicit name, expecting default to be the
	// assocaite of the client instance
	if err := client.Remove(name); err != nil {
		t.Fatal(err)
	}
}

// TestWithName ensures that an explicitly passed name is used in leau of the
// path derived name when provide, and persists through instantiations.
// This also ensures that an initialized service function's name persists if
// the path is changed after creation.
func TestWithName(t *testing.T) {
	// Explicit name to use
	name := "service.example.com"

	// Root which would derive to service.groupA.example.com were it not for the
	// explicitly provided name.
	root := "testdata/example.com/groupA/service"
	os.MkdirAll(root, 0700)
	defer os.RemoveAll(root)

	initializer := mock.NewInitializer()
	c, err := faas.New(
		faas.WithInitializer(initializer))
	if err != nil {
		t.Fatal(err)
	}

	// Ensure that initializing receives the specified name.
	initializer.InitializeFn = func(name2, language, path string) error {
		if name2 != name {
			t.Fatalf("initializer expected name '%v', got '%v'", name, name2)
		}
		return nil
	}

	// Create the service with the explict name at the non-matching root.
	if err := c.Create("go", name, root); err != nil {
		t.Fatal(err)
	}

	// Create  new client to test updating.
	updater := mock.NewUpdater()
	c, err = faas.New(
		faas.WithUpdater(updater))
	if err != nil {
		t.Fatal(err)
	}

	// Ensure that updating takes place using the previously initialized name
	updater.UpdateFn = func(name2, image string) error {
		if name2 != name {
			t.Fatalf("updater expected name '%v', got '%v'", name, name2)
		}
		return nil
	}

	// Invoke update
	if err := c.Update(root); err != nil {
		t.Fatal(err)
	}

}

// TestList ensures that the client invokes the configured lister.
func TestList(t *testing.T) {
	var lister = mock.NewLister()

	client, err := faas.New(
		faas.WithLister(lister)) // lists deployed service functions.
	if err != nil {
		t.Fatal(err)
	}

	_, err = client.List()
	if err != nil {
		t.Fatal(err)
	}

	if !lister.ListInvoked {
		t.Fatal("list did not invoke lister implementation")
	}
}

// TestListOutsideRoot ensures that a call to a function (in this case list)
// that is not contextually dependent on being associated with a function,
// can be run from anywhere, thus ensuring that the client itself makes
// a distinction between function-scoped methods and not.
func TestListOutsideRoot(t *testing.T) {
	var lister = mock.NewLister()

	// Instantiate in the current working directory, with no name, and explicitly
	// disallowing name path inferrence by limiting recursion.  This emulates
	// running the client (and subsequently list) from some arbitrary location
	// without a derivable funciton context.
	client, err := faas.New(
		faas.WithDomainSearchLimit(0),
		faas.WithLister(lister),
	)
	if err != nil {
		t.Fatal(err)
	}

	_, err = client.List()
	if err != nil {
		t.Fatal(err)
	}

	if !lister.ListInvoked {
		t.Fatal("list did not invoke lister implementation")
	}
}
